package array;

import easy.CommonUtil;

/**
 * Created by wm on 16/6/7.
 * <p/>
 * 1,完美洗牌算法
 * <p/>
 * 有个长度为2n的数组{a1,a2,a3,...,an,b1,b2,b3,...,bn}，希望排序后{a1,b1,a2,b2,....,an,bn}，请考虑有无时间复杂度o(n)，空间复杂度0(1)的解法。
 * <p/>
 * 1, 暴力遍历，
 * 步步前移， 挨个将b的元素一步步的向前移动，挨个交换，
 * 时间复杂度就是O(n2)
 * <p/>
 * 2, 中间元素交换策略，
 * 从中间位置开始，不断两两元素进行交换
 * 第①步：交换最中间的两个元素a4，b1，序列变成（待交换的元素用粗体表示）：
 * <p/>
 * a1，a2，a3，b1，a4，b2，b3，b4
 * <p/>
 * 第②步，让最中间的两对元素各自交换：
 * <p/>
 * a1，a2，b1，a3，b2，a4，b3，b4
 * <p/>
 * 时间复杂度还是 o(n2)
 * <p/>
 * 3, 完美洗牌算法，O(n2) O(1)
 * 根据移动的规律，分析下一个元素要移动到哪，
 * 起始序列：a1 a2 a3 a4 b1 b2 b3 b4
 * 数组下标：1 2 3 4 5 6 7 8
 * 最终序列：b1 a1 b2 a2 b3 a3 b4 a4
 * <p/>
 * 从上面的例子我们能看到，前n个元素中，
 * > 第1个元素a1到了原第2个元素a2的位置，即1->2；
 * > 第2个元素a2到了原第4个元素a4的位置，即2->4；
 * > 第3个元素a3到了原第6个元素b2的位置，即3->6；
 * > 第4个元素a4到了原第8个元素b4的位置，即4->8；
 * >
 * <p/>
 * 那么推广到一般情况即是：前n个元素中，第i个元素去了 第（2 * i）的位置。
 * <p/>
 * 上面是针对前n个元素，那么针对后n个元素，可以看出：
 * > 第5个元素b1到了原第1个元素a1的位置，即5->1；
 * > 第6个元素b2到了原第3个元素a3的位置，即6->3；
 * > 第7个元素b3到了原第5个元素b1的位置，即7->5；
 * > 第8个元素b4到了原第7个元素b3的位置，即8->7；
 * <p/>
 * 推广到一般情况是，后n个元素，第i个元素去了第 (2 * (i - n) ) - 1 = 2 * i - (2 * n + 1) = (2 * i) % (2 * n + 1) 个位置。
 * <p/>
 * 再综合到任意情况，任意的第i个元素，我们最终换到了 (2 * i) % (2 * n + 1)的位置。为何呢？因为：
 * > 当0 < i < n时， 原式= (2i) % (2 * n + 1) = 2i；
 * > 当i > n时，原式(2 * i) % (2 * n + 1)保持不变。
 */
public class ArrayShuffle {

    public static void main(String[] args) {

        CommonUtil.show(pefectShuffle1(new int[]{1, 3, 5, 7, 2, 4, 6, 8}, 4));

    }

    // 时间O(n)，空间O(n) 数组下标从1开始
    // n 表示前半部分的元素，
    public static int[] pefectShuffle1(int[] a, int n) {
        int n2 = n * 2, i;
        int[] b = new int[2 * n + 1];
        for (i = 1; i <= n2; ++i) {
            b[(i * 2) % (n * 2 + 1)] = a[i - 1];
        }
        for (i = 1; i <= n2; ++i) {
            a[i - 1] = b[i];
        }

        return a;

    }


}

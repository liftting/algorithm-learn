3-30:
Pailie  : 字符串的全排列逻辑处理，提供 递归和非递归的处理逻辑

SingleNumber : 利用亦或的公式特性处理的

CountBits : 计算数的二进制包含的1个数， 因为有限制，也是利用了亦或的特性



3-31:
ArrayExeptSelf :给一个数组，计算别的数的乘积， 注意0情况即可

BulbSwitcher: 开关切换，线性的时间，是利用一个原理，
非线性的就是普通的遍历， 注意，n /2 一半的处理，和 倍数的循环



4-1：
FindMinArray:排序数组，查找最小，二分，

DivideNumber: 利用二进制的加 减处理

ThreeSumZero: 三个数，排序，利用索引，注意时间复杂度的降低，left 初始位置，

WordSearch： 类似树的搜索， 回溯法解决，递归

4-5:
ParenthesesTree  这个是 填 字符串，()()()，求出排列的方式，
这个可以划分成树的方式来处理，

WordLadder : 注意广搜的写法， 不是递归的，  同时注意判断字符相等的策略


4-6：
GasStation : 加油站，消耗，能否回来问题， 有暴力

FlattenBinaryTree ： 转换成一个右边的长长的链表问题，


4-7:
MultiNumberAddSum ：下面是一类问题，一个数组，几个数相加等于一个sum，求所有可能，暴力递归，超时
ThreeNumber:
FourSum:  也可以多重循环判断

InsertSortLinkedList:单链表的插入排序，第一个元素后插入


WordBreaker: 词的截取， DFS深搜，递归，切换不同的起点即可，

LCA ： 链表的最近公共祖先， 一个先走，m 两个一起走问题


4-11:
IntersectLinkedList: 链表，先走问题
JumGame : 移动的范围，有规则

DecodeWays: DP (12-AB 或者L ，所以有个地推公式

LinkedListCycle:  链表带环，走一步， 两步，相交那么久有环
LinkedListCycleBegin:类似上面，但是判断交点入口，有个规则，


AddListNodeNumber:两个链表数相加， 考虑进位， 只考虑一个数字的进位，不可能一次两个进位

CoinSelect: DP问题，硬币搜集
LongAscArray: DP , 最长非降子序列

4-12:
LeetPhoneNumber: 使用递归，带着集合进行下一次的递归操作

ArrayConvertTree: 将数组转换为高度平衡的 二叉树，那么每次构建节点时，都取中间的位置节点
ListConvertTree: 类似上面的，链表转换为数组即可，

BinarySearchTreeUnique: 这个难， 其实是两个问题， 给一个数，判断1-n 中能构建出多少个二叉树，
而满足二叉树的规则是，左边 要小于节点，右边大于节点，
那么每个节点都作为子节点，进行左边递归， 和右边递归，
每次递归出来，都起始以当前节点为根的节点，子树情况，都会添加进来，

那返回的集合就是节点数目，
在求数目时，递归超时，使用DP

MaxSubArray:
求一个数组的最大子数组， 因为要保持连冠，所以有策略
三种方法：暴力O(n2) 分治（类似归并排序，可参考，） ，一个策略DP问题

MissingNumber :
一个连续数组缺少元素，查找，有特殊的判断方法，加和，
或者排序，然后查找，基本方法


4-13:
MaxProductArray: 子数组问题变种， 数组数据相乘最大， 那就要记住最小和最大，也是dp

Triangle: 特殊三角， 即 最短路径值问题， DP问题，从小计算到大问题，


4-14：

MinPathSum: 二维数组，求到右下角，最小的值， DP ，根据之前计算后面的

UniquePath：求有多少条路径，到一个二维数组的右下角， 也是 DP ，能降低时间复杂度，用数组保存之前的计算结果，但是也是个排列问题

MaxSubString: 一个字符串，字串，连续，没有重复，  技巧，使用HashMap 来存储，用区分重复，也要注意，索引位置的变化判断




==
4-25
BuySellStock :
dp 问题， 购买股票赚的最大

SubSets:
排列组合选取问题，选 不选  递归，求子集

SumRootToLeaf:
树的，从根到子节点问题，

4-26
ThreeSuClosest:
三个数相加， 处理逻辑就是固定遍历一个数， 两个指针来回移动即可，要先排序

Permutation:
数组的全排列， 可递归实现， 交换，不断子集的交换

排列的线性算法有点问题：


5-9：二分查找题
SearchForRanage: 查找一个数据 带范围的，二分查找，范围后继续二分

SearchInsertPos:查找插入的位置，有序就是二分处理

SearchRotatedSoryArray:数组原来是有序的，现在在某一个位置配反转了，查找元素所在的索引位置，二分原理，有技巧

setMatrixZeros: 一个二维数组，置0，空间复杂度O(m+n)，但是有常数的空间复杂度

RotateList ：链表的反转，记录好几个特殊点的位置， （技巧，利用堆栈结构来处理）


5-10:
RemoveDuplicateSortArrayTwo:在数组中移除掉重复的两个 元素, 排序的，两位置标记即可

RemoveDuplicateSortListTwo: 链表的元素重复处理，注意创建个头结点，方便处理，

RoatteList: 链表反转， 多指针扫描，处理， 注意 取余数操作，

SortColors: 排序问题，快排，划分，

SetMatrixZeros: 设置为0问题，可优化地方是，常数 的额外空间暂用

SortList: 链表的排序，都是可以参考数组的，注意节点处理，这个使用的 归并排序

Combinations: 对于选择 不选择的 组合问题， 回溯法可以解决，注意状态还原

